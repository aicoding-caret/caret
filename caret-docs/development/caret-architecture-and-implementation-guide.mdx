# Caret 아키텍처 및 구현 가이드

## 1. 개요
이 문서는 Caret 프로젝트가 **Fork 기반 아키텍처**를 통해 Cline의 안정적인 기반 위에서 고유의 기능을 구현하는 방법을 안내합니다. Caret은 Cline 코드베이스를 직접 포함하여 기존 기능을 최대한 활용하면서, 필요한 부분만 선택적으로 확장하거나 대체하는 전략을 채택합니다.

## 2. Fork 기반 아키텍처 원칙

### 2.1. Cline 코드 직접 포함
Caret은 [Cline](https://github.com/cline/cline) 프로젝트의 **Fork**로, Cline의 전체 코드베이스를 `src/` 디렉토리에 직접 포함합니다. 이를 통해:
- Cline의 안정적이고 검증된 기능을 그대로 활용
- 업스트림 변경사항을 Git merge를 통해 효율적으로 통합
- 복잡한 서브모듈 관리나 외부 의존성 없이 단순한 구조 유지

### 2.2. 최소 확장 원칙
Caret의 확장 코드는 다음 원칙을 따릅니다:
- **Cline 코드 보존**: `src/`, `webview-ui/` 원본 파일은 가능한 수정하지 않음
- **최소 진입점**: `caret-src/extension.ts`를 통해 Cline 모듈 활용
- **점진적 확장**: 필요한 기능만 Caret 전용으로 구현

### 2.3. 핵심 디렉토리 구조
```
caret/
├── src/                      # Cline 원본 코드 (보존)
│   ├── extension.ts          # Cline 메인 진입점
│   ├── core/                 # Cline 핵심 로직
│   │   ├── webview/          # WebviewProvider
│   │   ├── task/             # Task 관리
│   │   └── prompts/          # 프롬프트 시스템
│   ├── shared/               # 공통 타입/유틸리티
│   └── api/                  # AI 프로바이더들
├── caret-src/                # Caret 확장 기능 (최소한)
│   ├── extension.ts          # Caret 진입점 (src/ 모듈 활용)
│   └── core/
│       └── webview/
│           └── CaretProvider.ts  # Cline WebviewProvider 확장
├── caret-assets/             # Caret 전용 에셋
│   ├── template_characters/  # AI 캐릭터 템플릿
│   ├── rules/                # 기본 모드 및 룰 정의
│   └── icons/                # 프로젝트 아이콘
├── caret-docs/               # Caret 전용 문서
└── webview-ui/               # 프론트엔드 (Cline 빌드 시스템 활용)
    ├── src/components/       # Cline 원본 컴포넌트 (보존)
    ├── src/caret/            # Caret 전용 컴포넌트
    ├── src/utils/            # Cline 유틸리티 + Caret 추가
    └── src/locale/           # Caret 다국어 지원
```

## 3. 구현 전략

### 3.1. 백엔드 확장 (caret-src)
**목적**: Cline의 핵심 기능을 활용하면서 Caret 고유 기능 추가

**구현 방식**:
1. **Cline 모듈 직접 활용**
   ```typescript
   // caret-src/extension.ts
   import { WebviewProvider } from '../src/core/webview/WebviewProvider';
   import { TaskManager } from '../src/core/task/TaskManager';
   
   // Cline 모듈을 직접 import하여 활용
   export class CaretProvider extends WebviewProvider {
     // Caret 고유 기능만 추가/오버라이드
   }
   ```

2. **클래스 상속을 통한 확장**
   ```typescript
   // caret-src/core/webview/CaretProvider.ts
   import { WebviewProvider } from '../../../src/core/webview/WebviewProvider';
   
   export class CaretProvider extends WebviewProvider {
     // 기존 메서드 오버라이드
     override async initialize(): Promise<void> {
       await super.initialize();
       // Caret 전용 초기화 로직
       await this.initializeCaretFeatures();
     }
   
     // 새로운 메서드 추가
     private async initializeCaretFeatures(): Promise<void> {
       // Caret 고유 기능 구현
     }
   }
   ```

### 3.2. 프론트엔드 확장 (webview-ui)
**목적**: Cline의 React 빌드 시스템을 그대로 활용하면서 UI 확장

**구현 방식**:
1. **컴포넌트 추가**
   ```typescript
   // webview-ui/src/caret/CaretWelcome.tsx
   import React from 'react';
   import { useExtensionState } from '../context/ExtensionStateContext';
   
   export const CaretWelcome: React.FC = () => {
     const { state } = useExtensionState();
     
     return (
       <div className="caret-welcome">
         {/* Caret 전용 웰컴 페이지 */}
       </div>
     );
   };
   ```

2. **라우팅 분기**
   ```typescript
   // webview-ui/src/App.tsx 수정 (필요시)
   import { CaretWelcome } from './caret/CaretWelcome';
   
   function App() {
     const isCaretMode = /* Caret 모드 판별 로직 */;
     
     if (isCaretMode) {
       return <CaretWelcome />;
     }
     
     // 기존 Cline UI
     return <ClineApp />;
   }
   ```

3. **유틸리티 추가**
   ```typescript
   // webview-ui/src/utils/caret-i18n.ts
   // webview-ui/src/utils/caret-webview-logger.ts
   // Caret 전용 유틸리티 함수들
   ```

### 3.3. 필요시 파일 교체
**원칙**: 최후의 수단으로만 사용, 반드시 백업 생성

**구현 방식**:
1. **원본 백업**
   ```bash
   # 원본 파일을 .cline 확장자로 백업
   cp webview-ui/src/components/Welcome.tsx webview-ui/src/components/Welcome-tsx.cline
   ```

2. **Caret 버전으로 교체**
   ```typescript
   // webview-ui/src/components/Welcome.tsx (교체됨)
   // Caret 전용 Welcome 컴포넌트 구현
   ```

3. **머징 가이드 업데이트**
   - `caret-docs/guides/upstream-merging.md`에 교체 파일 정보 기록

## 4. 빌드 시스템

### 4.1. 통합 빌드 프로세스
Caret은 Cline의 기존 빌드 시스템을 최대한 활용:

```bash
# Protocol Buffer 컴파일
npm run protos

# TypeScript 컴파일 (src/ + caret-src/ 통합)
npm run compile

# Webview UI 빌드 (Vite)
cd webview-ui && npm run build
```

### 4.2. 빌드 설정 최적화
- **tsconfig.json**: `src/`와 `caret-src/` 경로 포함
- **package.json**: Cline 스크립트 확장
- **vite.config.ts**: Caret 컴포넌트 경로 추가

## 5. 개발 워크플로우

### 5.1. 새 기능 개발
1. **요구사항 분석**: Cline 기존 기능으로 충족 가능한지 확인
2. **구현 방식 결정**: 확장 vs 교체 vs 신규 추가
3. **최소 구현**: 가능한 Cline 모듈 재사용
4. **테스트 및 로깅**: 모든 새 기능에 테스트와 로깅 포함

### 5.2. 업스트림 머징
1. **Cline 변경사항 확인**
2. **충돌 해결**: 주로 `src/` 디렉토리에서 발생
3. **Caret 기능 호환성 검증**
4. **문서 업데이트**

## 6. 품질 관리

### 6.1. 테스트 전략
- **Cline 기능**: 원본 테스트 그대로 유지
- **Caret 확장**: 100% 테스트 커버리지 목표
- **통합 테스트**: Cline-Caret 연동 검증

### 6.2. 로깅 시스템
```typescript
// caret-src/utils/logger.ts
import { Logger } from '../src/services/logging/Logger';

export const caretLogger = Logger.getLogger('Caret');

caretLogger.info('Caret feature initialized');
```

### 6.3. 코드 품질
- **ESLint/Prettier**: Cline 설정 준수
- **TypeScript**: 엄격한 타입 검사
- **코드 리뷰**: 모든 변경사항 검토

## 7. 성공 기준

### 7.1. 기술적 목표
- ✅ **빌드 성공**: `npm run compile` 오류 없음
- ✅ **확장 로드**: VSCode에서 Caret 정상 실행
- ✅ **기능 동작**: 기본 UI 표시 및 Cline 호환성

### 7.2. 아키텍처 목표
- ✅ **코드 재사용**: Cline 기능 최대 활용
- ✅ **확장성**: 새 기능 추가 용이성
- ✅ **유지보수성**: 업스트림 머징 원활함

## 8. 문제 해결 가이드

### 8.1. 일반적인 문제들
- **경로 오류**: `../../../src/` 경로 확인
- **타입 오류**: Cline 타입 정의 활용
- **빌드 실패**: Protocol Buffer 컴파일 선행

### 8.2. 디버깅 팁
- **VSCode 디버거**: F5로 확장 개발 환경 실행
- **콘솔 로그**: 개발자 도구에서 로그 확인
- **소스맵**: TypeScript 소스 레벨 디버깅

이 가이드는 Caret의 Fork 기반 아키텍처를 통해 안정적이고 확장 가능한 개발 환경을 구축하는 데 도움이 됩니다. 모든 변경사항은 이 원칙을 기반으로 진행되어야 합니다.